{
    "sourceFile": "src/app/api/tickets/route.ts",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1765300016718,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1765300016718,
            "name": "Commit-0",
            "content": "import { NextRequest, NextResponse } from \"next/server\";\nimport { getServerSession } from \"next-auth\";\nimport { authOptions } from \"@/app/lib/auth\";\nimport dbConnection from \"@/app/lib/dbconnection\";\nimport Ticket from \"@/app/models/ticket\";\nimport { sendTicketCreatedEmail } from \"@/app/services/emailService\";\n\n// POST - Crear un nuevo ticket\nexport async function POST(request: NextRequest) {\n  try {\n    const session = await getServerSession(authOptions);\n\n    if (!session?.user) {\n      return NextResponse.json(\n        { error: \"No autenticado\" },\n        { status: 401 }\n      );\n    }\n\n    const { title, description, priority } = await request.json();\n\n    // Validaciones básicas\n    if (!title || !description) {\n      return NextResponse.json(\n        { error: \"Título y descripción son requeridos\" },\n        { status: 400 }\n      );\n    }\n\n    await dbConnection();\n\n    // Crear el ticket asociado al usuario autenticado\n    const newTicket = await Ticket.create({\n      title,\n      description,\n      priority: priority || \"medium\",\n      status: \"open\",\n      clientId: (session.user as any).id,\n    });\n\n    // Poblar la información del cliente\n    await newTicket.populate(\"clientId\", \"name email\");\n\n    // Enviar correo al cliente\n    try {\n      const clientData = newTicket.clientId as any;\n      await sendTicketCreatedEmail({\n        clientEmail: clientData.email,\n        clientName: clientData.name,\n        ticketId: newTicket._id.toString(),\n        ticketTitle: newTicket.title,\n        ticketDescription: newTicket.description,\n      });\n    } catch (emailError) {\n      console.error(\"Error enviando email:\", emailError);\n      // No fallar el request si el email falla\n    }\n\n    return NextResponse.json(\n      {\n        message: \"Ticket creado exitosamente\",\n        ticket: newTicket,\n      },\n      { status: 201 }\n    );\n  } catch (error: any) {\n    console.error(\"Error al crear ticket:\", error);\n\n    if (error.name === \"ValidationError\") {\n      const messages = Object.values(error.errors).map((err: any) => err.message);\n      return NextResponse.json(\n        { error: messages.join(\", \") },\n        { status: 400 }\n      );\n    }\n\n    return NextResponse.json(\n      { error: \"Error al crear el ticket\" },\n      { status: 500 }\n    );\n  }\n}\n\n// GET - Obtener tickets\nexport async function GET(request: NextRequest) {\n  try {\n    const session = await getServerSession(authOptions);\n\n    if (!session?.user) {\n      return NextResponse.json(\n        { error: \"No autenticado\" },\n        { status: 401 }\n      );\n    }\n\n    await dbConnection();\n\n    const userRole = (session.user as any).role;\n    const userId = (session.user as any).id;\n\n    let tickets;\n\n    // Si es cliente, solo ve sus propios tickets\n    if (userRole === \"client\") {\n      tickets = await Ticket.find({ clientId: userId })\n        .populate(\"clientId\", \"name email\")\n        .populate(\"agentId\", \"name email\")\n        .sort({ createdAt: -1 });\n    } \n    // Si es agente, ve todos los tickets\n    else if (userRole === \"agent\") {\n      tickets = await Ticket.find()\n        .populate(\"clientId\", \"name email\")\n        .populate(\"agentId\", \"name email\")\n        .sort({ createdAt: -1 });\n    } else {\n      return NextResponse.json(\n        { error: \"Rol no autorizado\" },\n        { status: 403 }\n      );\n    }\n\n    return NextResponse.json(\n      { tickets },\n      { status: 200 }\n    );\n  } catch (error) {\n    console.error(\"Error al obtener tickets:\", error);\n    return NextResponse.json(\n      { error: \"Error al obtener tickets\" },\n      { status: 500 }\n    );\n  }\n}\n"
        }
    ]
}